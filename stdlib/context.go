// Code generated by 'yaegi extract context'. DO NOT EDIT.

// +build go1.16,!go1.17,stdbase

package stdlib

import (
	"context"
	"reflect"
	"time"
)

func init() {
	Symbols["context/context"] = map[string]reflect.Value{
		// function, constant and variable definitions
		"Background":       reflect.ValueOf(context.Background),
		"Canceled":         reflect.ValueOf(&context.Canceled).Elem(),
		"DeadlineExceeded": reflect.ValueOf(&context.DeadlineExceeded).Elem(),
		"TODO":             reflect.ValueOf(context.TODO),
		"WithCancel":       reflect.ValueOf(context.WithCancel),
		"WithDeadline":     reflect.ValueOf(context.WithDeadline),
		"WithTimeout":      reflect.ValueOf(context.WithTimeout),
		"WithValue":        reflect.ValueOf(context.WithValue),

		// type definitions
		"CancelFunc": reflect.ValueOf((*context.CancelFunc)(nil)),
		"Context":    reflect.ValueOf((*context.Context)(nil)),

		// interface wrapper definitions
		"_Context": reflect.ValueOf((*_context_Context)(nil)),
	}
}

// _context_Context is an interface wrapper for Context type
type _context_Context struct {
	IValue    interface{}
	WDeadline func() (deadline time.Time, ok bool)
	WDone     func() (r0 <-chan struct{})
	WErr      func() (r0 error)
	WValue    func(key interface{}) (r0 interface{})
}

func (W _context_Context) Deadline() (deadline time.Time, ok bool) {
	if W.WDeadline == nil {
		return
	}
	return W.WDeadline()
}
func (W _context_Context) Done() (r0 <-chan struct{}) {
	if W.WDone == nil {
		return
	}
	return W.WDone()
}
func (W _context_Context) Err() (r0 error) {
	if W.WErr == nil {
		return
	}
	return W.WErr()
}
func (W _context_Context) Value(key interface{}) (r0 interface{}) {
	if W.WValue == nil {
		return
	}
	return W.WValue(key)
}
