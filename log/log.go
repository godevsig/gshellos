package log

import (
	"fmt"
	"os"
	"path"
	"runtime"
	"strings"
	"sync"
	"time"
)

// Flag controls output format
type Flag uint32

// These flags define which text to prefix to each log entry generated by the Logger.
// Bits are or'ed together to control what's printed.
const (
	Ldefault  Flag = 0
	LUTC      Flag = 1 << 0 // use UTC rather than the local time zone
	Lfileline Flag = 1 << 1 // the file and line in the source code that prints the message
)

// Loglevel is one of the predefined loglevels
type Loglevel uint32

// All predefined loglevels
const (
	Ltrace Loglevel = 1
	Ldebug Loglevel = 2
	Linfo  Loglevel = 3
	Lwarn  Loglevel = 4
	Lerror Loglevel = 5
	Lfatal Loglevel = 6
)

// Logger is the logger instance
type Logger struct {
	stream *Stream // the stream it belongs to
	name   string
	level  Loglevel
}

type logEntry struct {
	time       string
	loggerName string
	level      string
	fileLine   string
	rawMsg     string
}

type outputter interface {
	output(*logEntry)
}

// Stream is a output stream handle, all loggers under a stream share one
// output destination and same log format, but can have separete loglevel.
type Stream struct {
	name         string
	flag         Flag
	timeFormat   string
	level        Loglevel // value of calling SetLoglevel() the last time
	matchPattern string   // pattern of calling SetLoglevel() the last time
	loggers      map[string]*Logger
	dataMutex    sync.RWMutex // protect fields above

	outputter
	mutex sync.RWMutex // protect output and close
}

// DefaultStream is the builtin output stream instance
var DefaultStream *Stream

// all streams that have been created.
var allStreams = make(map[string]*Stream)
var mtx sync.Mutex

func init() {
	DefaultStream = NewStream("default")
	newOutputterFactory("file", fileFactory{})
}

// NewStream creates a Stream instance
func NewStream(name string) *Stream {
	if len(name) == 0 {
		panic("empty name")
	}

	s := &Stream{
		name:         name,
		flag:         Ldefault,
		timeFormat:   "[2006/01/02 15:04:05.000000]",
		level:        Linfo,
		matchPattern: "",
		loggers:      make(map[string]*Logger),
		outputter:    stdout{},
	}

	mtx.Lock()
	allStreams[name] = s
	mtx.Unlock()
	return s
}

// GetStream returns the Stream handle if it has been created with the same input
// "name", returns nil if not.
// Usually used for a subpackage other than main to get the named Stream handle.
func GetStream(name string) *Stream {
	mtx.Lock()
	defer mtx.Unlock()
	return allStreams[name]
}

// SetFlag sets the flag to control output format.
func (s *Stream) SetFlag(newFlag Flag) {
	// uint32 on modern CPU should be atomic
	s.flag = newFlag
}

type outputterFactory interface {
	newOutputter(description string) (outputter, error)
}

type stdout struct{}
type file struct {
	fd *os.File
}
type fileFactory struct{}

func (stdout) output(le *logEntry) {
	o := file{fd: os.Stdout}
	o.output(le)
}

func (f file) output(le *logEntry) {
	var sb strings.Builder
	if len(le.time) != 0 {
		sb.WriteString(le.time)
	}
	sb.WriteString(le.loggerName)
	sb.WriteString("[" + le.level + "]")
	if len(le.fileLine) != 0 {
		sb.WriteString(le.fileLine)
	}
	sb.WriteByte(' ')
	sb.WriteString(le.rawMsg)

	sr := strings.NewReader(sb.String())
	sr.WriteTo(f.fd)
}

type closer interface {
	close()
}

func (f file) close() {
	f.fd.Close()
}

func (fileFactory) newOutputter(filename string) (outputter, error) {
	if len(filename) == 0 {
		return nil, fmt.Errorf("file name is empty")
	}

	dir := path.Dir(filename)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return nil, err
	}

	// If the file doesn't exist, create it, or append to the file
	f, err := os.OpenFile(filename, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		return nil, err
	}

	return file{fd: f}, nil
}

var allFactories = make(map[string]outputterFactory)

// no lock here, use it in init()
func newOutputterFactory(keyword string, f outputterFactory) {
	allFactories[keyword] = f
}

// Close closes the stream.
func (s *Stream) Close() {
	for _, lg := range s.loggers {
		lg.Close()
	}
	s.mutex.Lock()
	if v, ok := s.outputter.(closer); ok {
		v.close()
	}
	s.mutex.Unlock()

	mtx.Lock()
	delete(allStreams, s.name)
	mtx.Unlock()
	*s = Stream{}
}

// SetOutput sets the output destination to the new one, and close the old one.
// newOutputDest is in the form: "keyword:description". See supported output destination keywords.
func (s *Stream) SetOutput(newOutputDest string) error {
	ss := strings.Split(newOutputDest, ":")
	keyword := ss[0]
	description := strings.Join(ss[1:], ":")

	// create the new outputter
	var newOutputter outputter
	if keyword == "stdout" {
		newOutputter = stdout{}
	} else {
		f, has := allFactories[keyword]
		if !has {
			return fmt.Errorf("keyword: %s is not supported", keyword)
		}
		otptr, err := f.newOutputter(description)
		if err != nil {
			return fmt.Errorf("failed to create output for %s, error: %w", keyword, err)
		}
		newOutputter = otptr
	}

	// close the old one
	s.mutex.Lock()
	if v, ok := s.outputter.(closer); ok {
		v.close()
	}
	s.outputter = newOutputter
	s.mutex.Unlock()

	return nil
}

// SetTimeFormat can change the timestamp format, refer to standard time package for the possible formats.
// An empty string "" will disable timestamp to be printed.
func (s *Stream) SetTimeFormat(newFormat string) {
	if len(s.name) == 0 {
		panic("closed stream")
	}
	s.dataMutex.Lock()
	s.timeFormat = newFormat
	s.dataMutex.Unlock()
}

func patternMatch(str, pattern string) bool {
	if len(pattern) == 0 {
		return false
	}
	strs := strings.Split(pattern, "*")
	var pos, index int
	if index = strings.Index(str, strs[0]); index != 0 {
		return false
	}
	end := strs[len(strs)-1]
	if index = strings.LastIndex(str, end); index+len(end) != len(str) {
		return false
	}
	for i, substr := range strs {
		if i == 0 || i == len(strs)-1 || len(substr) == 0 {
			continue
		}
		index = strings.Index(str[pos:], substr)
		if index == -1 {
			return false
		}
		pos += index + len(substr)
	}
	return true
}

// SetLoglevel set the loglevel for every logger instance if its name matches the namePattern.
// namePattern is a simple wildcard pattern, i.e. *foo*bar*, and supports multiple patterns,
// i.e. "*foo,bar*,worker123", patterns are separated by a comma.
func (s *Stream) SetLoglevel(namePattern string, newLevel Loglevel) {
	if len(s.name) == 0 {
		panic("closed stream")
	}
	patterns := strings.Split(namePattern, ",")
	if len(patterns) == 0 {
		return
	}
	func() {
		s.dataMutex.RLock()
		defer s.dataMutex.RUnlock()
		for name, lg := range s.loggers {
			for _, pattern := range patterns {
				if patternMatch(name[1:len(name)-1], pattern) {
					lg.SetLoglevel(newLevel)
					break
				}
			}
		}
	}()

	s.dataMutex.Lock()
	s.matchPattern = namePattern
	s.level = newLevel
	s.dataMutex.Unlock()
}

// AllLoggerNames returns the logger names under the stream.
func (s *Stream) AllLoggerNames() (names []string) {
	if len(s.name) == 0 {
		panic("closed stream")
	}
	s.dataMutex.RLock()
	defer s.dataMutex.RUnlock()
	for name := range s.loggers {
		names = append(names, name[1:len(name)-1])
	}
	return names
}

// GetLogger returns logger instance that has been created or nil if not.
func (s *Stream) GetLogger(name string) *Logger {
	if len(s.name) == 0 {
		panic("closed stream")
	}
	if len(name) == 0 {
		return nil
	}
	name = fmt.Sprintf("[%s]", name)
	s.dataMutex.RLock()
	defer s.dataMutex.RUnlock()
	if lg, has := s.loggers[name]; has {
		return lg
	}
	return nil
}

// NewLogger returns a logger instance.
// In a project where all logs go to the same destination, using builtin DefaultStream is enough.
// In case multiple destinations are needed, use "named" stream returned by NewStream().
//  stream is the stream that the logger instance belongs to.
//  name is the identifier of the logger, which is assembled to each log entry.
//  defaultLoglevel sets the default loglevel of the returned logger instance.
// Unless the name matches preconfigured namePattern, in which case loglevel sets to preconfigured loglevel.
// see Stream.SetLoglevel().
// Returns nil if stream is nil or name is empty.
func (s *Stream) NewLogger(name string, defaultLoglevel Loglevel) *Logger {
	if len(s.name) == 0 {
		panic("closed stream")
	}
	if len(name) == 0 {
		return nil
	}

	lgname := fmt.Sprintf("[%s]", name)
	lg := &Logger{stream: s, name: lgname, level: defaultLoglevel}

	// check if we are the target pettern
	s.dataMutex.RLock()
	matchPattern := s.matchPattern
	level := s.level
	s.dataMutex.RUnlock()
	patterns := strings.Split(matchPattern, ",")
	for _, pattern := range patterns {
		if patternMatch(name, pattern) {
			lg.level = level
			break
		}
	}

	s.dataMutex.Lock()
	if _, has := s.loggers[lgname]; has {
		err := fmt.Errorf("Fatal: logger named %s already exists in %v", name, s.loggers)
		panic(err)
	}
	s.loggers[lgname] = lg
	s.dataMutex.Unlock()
	return lg
}

// Close releases the logger
func (lg *Logger) Close() {
	lg.stream.dataMutex.Lock()
	delete(lg.stream.loggers, lg.name)
	lg.stream.dataMutex.Unlock()
	*lg = Logger{}
}

// SetLoglevel sets the log level of the logger instance.
func (lg *Logger) SetLoglevel(level Loglevel) {
	// uint32 on modern CPU should be atomic
	lg.level = level
}

func (lg *Logger) outputLogEntry(level, format string, args []interface{}) {
	if lg.stream == nil {
		panic("closed logger")
	}
	entry := &logEntry{}
	entry.loggerName = lg.name
	entry.level = level

	if len(format) == 0 {
		// println
		entry.rawMsg = fmt.Sprintln(args...)
	} else {
		// printf, append \n
		var msg strings.Builder
		fmt.Fprintf(&msg, format, args...)
		if msg.Len() == 0 || msg.String()[msg.Len()-1] != '\n' {
			msg.WriteByte('\n')
		}
		entry.rawMsg = msg.String()
	}

	lg.stream.dataMutex.RLock()
	timeFormat := lg.stream.timeFormat
	lg.stream.dataMutex.RUnlock()
	if len(timeFormat) != 0 {
		t := time.Now()
		if lg.stream.flag&LUTC != 0 {
			t = t.UTC()
		}
		entry.time = t.Format(timeFormat)
	}

	if lg.stream.flag&Lfileline != 0 {
		fileLine := "(???:0)"
		_, file, line, ok := runtime.Caller(3)
		if ok {
			fileLine = fmt.Sprintf("(%s:%d)", path.Base(file), line)
		}
		entry.fileLine = fileLine
	}

	lg.stream.mutex.Lock()
	lg.stream.output(entry)
	lg.stream.mutex.Unlock()
}

func (lg *Logger) trace(format string, args []interface{}) {
	if lg.level > Ltrace {
		return
	}
	lg.outputLogEntry("TRACE", format, args)
}

// Tracef writes the trace log, always adds a '\n' if no '\n' supplied by user
func (lg *Logger) Tracef(format string, args ...interface{}) {
	lg.trace(format, args)
}

// Traceln is like fmt.Println with loglevel trace
func (lg *Logger) Traceln(args ...interface{}) {
	lg.trace("", args)
}

func (lg *Logger) debug(format string, args []interface{}) {
	if lg.level > Ldebug {
		return
	}
	lg.outputLogEntry("DEBUG", format, args)
}

// Debugf writes the debug log, always adds a '\n' if no '\n' supplied by user
func (lg *Logger) Debugf(format string, args ...interface{}) {
	lg.debug(format, args)
}

// Debugln is like fmt.Println with loglevel debug
func (lg *Logger) Debugln(args ...interface{}) {
	lg.debug("", args)
}

func (lg *Logger) info(format string, args []interface{}) {
	if lg.level > Linfo {
		return
	}
	lg.outputLogEntry("INFO", format, args)
}

// Infof writes the info log, always adds a '\n' if no '\n' supplied by user
func (lg *Logger) Infof(format string, args ...interface{}) {
	lg.info(format, args)
}

// Infoln is like fmt.Println with loglevel info
func (lg *Logger) Infoln(args ...interface{}) {
	lg.info("", args)
}

func (lg *Logger) warn(format string, args []interface{}) {
	if lg.level > Lwarn {
		return
	}
	lg.outputLogEntry("WARN", format, args)
}

// Warnf writes the warning log, always adds a '\n' if no '\n' supplied by user
func (lg *Logger) Warnf(format string, args ...interface{}) {
	lg.warn(format, args)
}

// Warnln is like fmt.Println with loglevel warning
func (lg *Logger) Warnln(args ...interface{}) {
	lg.warn("", args)
}

func (lg *Logger) error(format string, args []interface{}) {
	if lg.level > Lerror {
		return
	}
	lg.outputLogEntry("ERROR", format, args)
}

// Errorf writes the error log, always adds a '\n' if no '\n' supplied by user
func (lg *Logger) Errorf(format string, args ...interface{}) {
	lg.error(format, args)
}

// Errorln is like fmt.Println with loglevel error
func (lg *Logger) Errorln(args ...interface{}) {
	lg.error("", args)
}

// Fatalf writes the log entry followed by a panic, always adds a '\n' if no '\n' supplied by user
func (lg *Logger) Fatalf(format string, args ...interface{}) {
	lg.outputLogEntry("FATAL", format, args)
	panic(fmt.Sprintf(format, args...))
}

// Fatalln is like fmt.Println with loglevel fatal followed by a panic
func (lg *Logger) Fatalln(args ...interface{}) {
	lg.outputLogEntry("FATAL", "", args)
	panic(fmt.Sprintln(args...))
}
