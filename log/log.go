package log

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"path"
	"runtime"
	"strings"
	"sync"
	"time"
)

// Flag controls output format
type Flag uint32

// These flags define which text to prefix to each log entry generated by the Logger.
// Bits are or'ed together to control what's printed.
const (
	Ldefault  Flag = 0
	LUTC      Flag = 1 << 0 // use UTC rather than the local time zone
	Lfileline Flag = 1 << 1 // the file and line in the source code that prints the message
)

// Loglevel is one of the predefined loglevels
type Loglevel uint32

// All predefined loglevels
const (
	Ltrace Loglevel = 1
	Ldebug Loglevel = 2
	Linfo  Loglevel = 3
	Lwarn  Loglevel = 4
	Lerror Loglevel = 5
	Lfatal Loglevel = 6
)

// Logger is the logger instance
type Logger struct {
	stream *Stream // the stream it belongs to
	name   string
	level  Loglevel
}

// Outputter outputs the log line.
// The (old) Outputter will be closed when closing the stream or changing
// the stream's output destination.
type Outputter io.WriteCloser

type stdout struct{}

func (stdout) Write(p []byte) (n int, err error) {
	f := file{os.Stdout}
	return f.Write(p)
}
func (stdout) Close() error { return nil }

type file struct {
	*os.File
}

// OutputterFactory is an outputter type.
type OutputterFactory interface {
	NewOutputter(description string) (Outputter, error)
}

type fileFactory struct{}

func (fileFactory) NewOutputter(filename string) (Outputter, error) {
	if len(filename) == 0 {
		return nil, fmt.Errorf("file name is empty")
	}

	dir := path.Dir(filename)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return nil, err
	}

	// If the file doesn't exist, create it, or append to the file
	f, err := os.OpenFile(filename, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		return nil, err
	}

	return file{f}, nil
}

var allFactories = make(map[string]OutputterFactory)

// RegOutputterFactory registers an output destination type.
// No lock here, use it in init().
func RegOutputterFactory(keyword string, f OutputterFactory) {
	allFactories[keyword] = f
}

// Stream is a output stream handle, all loggers under a stream share one
// output destination and same log format, but can have separete loglevel.
type Stream struct {
	name         string
	flag         Flag
	timeFormat   string
	level        Loglevel // value of calling SetLoglevel() the last time
	matchPattern string   // pattern of calling SetLoglevel() the last time
	loggers      map[string]*Logger
	dataMutex    sync.RWMutex // protect fields above

	outputter Outputter
	mutex     sync.RWMutex // protect output and close
}

// DefaultStream is the builtin output stream instance
var DefaultStream = NewStream("default")

// all streams that have been created.
var allStreams = make(map[string]*Stream)
var mtx sync.Mutex

func init() {
	RegOutputterFactory("file", fileFactory{})
}

// NewStream creates a Stream instance
func NewStream(name string) *Stream {
	if len(name) == 0 {
		panic("empty name")
	}

	s := &Stream{
		name:         name,
		flag:         Ldefault,
		timeFormat:   "[2006/01/02 15:04:05.000000]",
		level:        Linfo,
		matchPattern: "",
		loggers:      make(map[string]*Logger),
		outputter:    stdout{},
	}

	mtx.Lock()
	allStreams[name] = s
	mtx.Unlock()
	return s
}

// GetStream returns the Stream handle if it has been created with the same input
// "name", returns nil if not.
// Usually used for a subpackage other than main to get the named Stream handle.
func GetStream(name string) *Stream {
	mtx.Lock()
	defer mtx.Unlock()
	return allStreams[name]
}

// SetFlag sets the flag to control output format.
func (s *Stream) SetFlag(newFlag Flag) {
	// uint32 on modern CPU should be atomic
	s.flag = newFlag
}

// Close closes the stream.
func (s *Stream) Close() {
	for _, lg := range s.loggers {
		lg.Close()
	}
	s.mutex.Lock()
	s.outputter.Close()
	s.mutex.Unlock()

	mtx.Lock()
	delete(allStreams, s.name)
	mtx.Unlock()
	*s = Stream{}
}

// SetOutput sets the output destination to the new one, and close the old one.
// newOutputDest is in the form: "keyword:description". See supported output destination keywords.
func (s *Stream) SetOutput(newOutputDest string) error {
	ss := strings.Split(newOutputDest, ":")
	keyword := ss[0]
	description := strings.Join(ss[1:], ":")

	// create the new outputter
	var newOutputter Outputter
	if keyword == "stdout" {
		newOutputter = stdout{}
	} else {
		f, has := allFactories[keyword]
		if !has {
			return fmt.Errorf("keyword: %s is not supported", keyword)
		}
		otptr, err := f.NewOutputter(description)
		if err != nil {
			return fmt.Errorf("failed to create output for %s, error: %w", keyword, err)
		}
		newOutputter = otptr
	}

	// close the old one
	s.mutex.Lock()
	s.outputter.Close()
	s.outputter = newOutputter
	s.mutex.Unlock()

	return nil
}

// SetTimeFormat can change the timestamp format, refer to standard time package for the possible formats.
// An empty string "" will disable timestamp to be printed.
func (s *Stream) SetTimeFormat(newFormat string) {
	if len(s.name) == 0 {
		panic("closed stream")
	}
	s.dataMutex.Lock()
	s.timeFormat = newFormat
	s.dataMutex.Unlock()
}

func patternMatch(str, pattern string) bool {
	if len(pattern) == 0 {
		return false
	}
	strs := strings.Split(pattern, "*")
	var pos, index int
	if index = strings.Index(str, strs[0]); index != 0 {
		return false
	}
	end := strs[len(strs)-1]
	if index = strings.LastIndex(str, end); index+len(end) != len(str) {
		return false
	}
	for i, substr := range strs {
		if i == 0 || i == len(strs)-1 || len(substr) == 0 {
			continue
		}
		index = strings.Index(str[pos:], substr)
		if index == -1 {
			return false
		}
		pos += index + len(substr)
	}
	return true
}

// SetLoglevel set the loglevel for every logger instance if its name matches the namePattern.
// namePattern is a simple wildcard pattern, i.e. *foo*bar*, and supports multiple patterns,
// i.e. "*foo,bar*,worker123", patterns are separated by a comma.
func (s *Stream) SetLoglevel(namePattern string, newLevel Loglevel) {
	if len(s.name) == 0 {
		panic("closed stream")
	}
	patterns := strings.Split(namePattern, ",")
	if len(patterns) == 0 {
		return
	}
	func() {
		s.dataMutex.RLock()
		defer s.dataMutex.RUnlock()
		for name, lg := range s.loggers {
			for _, pattern := range patterns {
				if patternMatch(name[1:len(name)-1], pattern) {
					lg.SetLoglevel(newLevel)
					break
				}
			}
		}
	}()

	s.dataMutex.Lock()
	s.matchPattern = namePattern
	s.level = newLevel
	s.dataMutex.Unlock()
}

// AllLoggerNames returns the logger names under the stream.
func (s *Stream) AllLoggerNames() (names []string) {
	if len(s.name) == 0 {
		panic("closed stream")
	}
	s.dataMutex.RLock()
	defer s.dataMutex.RUnlock()
	for name := range s.loggers {
		names = append(names, name[1:len(name)-1])
	}
	return names
}

// GetLogger returns logger instance that has been created or nil if not.
func (s *Stream) GetLogger(name string) *Logger {
	if len(s.name) == 0 {
		panic("closed stream")
	}
	if len(name) == 0 {
		return nil
	}
	name = fmt.Sprintf("[%s]", name)
	s.dataMutex.RLock()
	defer s.dataMutex.RUnlock()
	if lg, has := s.loggers[name]; has {
		return lg
	}
	return nil
}

// NewLogger returns a logger instance.
// In a project where all logs go to the same destination, using builtin DefaultStream is enough.
// In case multiple destinations are needed, use "named" stream returned by NewStream().
// stream is the stream that the logger instance belongs to.
// name is the identifier of the logger, which is assembled to each log entry.
// defaultLoglevel sets the default loglevel of the returned logger instance, unless the name
// matches preconfigured namePattern, in which case loglevel sets to preconfigured loglevel.
// See Stream.SetLoglevel().
// Returns nil if stream is nil or name is empty.
func (s *Stream) NewLogger(name string, defaultLoglevel Loglevel) *Logger {
	if len(s.name) == 0 {
		panic("closed stream")
	}
	if len(name) == 0 {
		return nil
	}

	lgname := fmt.Sprintf("[%s]", name)
	lg := &Logger{stream: s, name: lgname, level: defaultLoglevel}

	// check if we are the target pettern
	s.dataMutex.RLock()
	matchPattern := s.matchPattern
	level := s.level
	s.dataMutex.RUnlock()
	patterns := strings.Split(matchPattern, ",")
	for _, pattern := range patterns {
		if patternMatch(name, pattern) {
			lg.level = level
			break
		}
	}

	s.dataMutex.Lock()
	if _, has := s.loggers[lgname]; has {
		err := fmt.Errorf("Fatal: logger named %s already exists in %v", name, s.loggers)
		panic(err)
	}
	s.loggers[lgname] = lg
	s.dataMutex.Unlock()
	return lg
}

// Close releases the logger
func (lg *Logger) Close() {
	lg.stream.dataMutex.Lock()
	delete(lg.stream.loggers, lg.name)
	lg.stream.dataMutex.Unlock()
	*lg = Logger{}
}

// SetLoglevel sets the log level of the logger instance.
func (lg *Logger) SetLoglevel(level Loglevel) {
	// uint32 on modern CPU should be atomic
	lg.level = level
}

func (lg *Logger) output(level, format string, args []interface{}) {
	if lg.stream == nil {
		panic("closed logger")
	}
	var b bytes.Buffer

	lg.stream.dataMutex.RLock()
	timeFormat := lg.stream.timeFormat
	lg.stream.dataMutex.RUnlock()
	if len(timeFormat) != 0 {
		t := time.Now()
		if lg.stream.flag&LUTC != 0 {
			t = t.UTC()
		}
		b.WriteString(t.Format(timeFormat))
	}

	b.WriteString(lg.name)
	b.WriteString(level)

	if lg.stream.flag&Lfileline != 0 {
		fileLine := "(???:0)"
		_, file, line, ok := runtime.Caller(3)
		if ok {
			fileLine = fmt.Sprintf("(%s:%d)", path.Base(file), line)
		}
		b.WriteString(fileLine)
	}
	b.WriteByte(' ')

	if len(format) == 0 {
		// println
		b.WriteString(fmt.Sprintln(args...))
	} else {
		// printf, append \n
		fmt.Fprintf(&b, format, args...)
		if b.Bytes()[b.Len()-1] != '\n' {
			b.WriteByte('\n')
		}
	}

	lg.stream.mutex.Lock()
	b.WriteTo(lg.stream.outputter)
	lg.stream.mutex.Unlock()
}

func (lg *Logger) trace(format string, args []interface{}) {
	if lg.level > Ltrace {
		return
	}
	lg.output("[TRACE]", format, args)
}

// Tracef writes the trace log, always adds a '\n' if no '\n' supplied by user
func (lg *Logger) Tracef(format string, args ...interface{}) {
	lg.trace(format, args)
}

// Traceln is like fmt.Println with loglevel trace
func (lg *Logger) Traceln(args ...interface{}) {
	lg.trace("", args)
}

func (lg *Logger) debug(format string, args []interface{}) {
	if lg.level > Ldebug {
		return
	}
	lg.output("[DEBUG]", format, args)
}

// Debugf writes the debug log, always adds a '\n' if no '\n' supplied by user
func (lg *Logger) Debugf(format string, args ...interface{}) {
	lg.debug(format, args)
}

// Debugln is like fmt.Println with loglevel debug
func (lg *Logger) Debugln(args ...interface{}) {
	lg.debug("", args)
}

func (lg *Logger) info(format string, args []interface{}) {
	if lg.level > Linfo {
		return
	}
	lg.output("[INFO]", format, args)
}

// Infof writes the info log, always adds a '\n' if no '\n' supplied by user
func (lg *Logger) Infof(format string, args ...interface{}) {
	lg.info(format, args)
}

// Infoln is like fmt.Println with loglevel info
func (lg *Logger) Infoln(args ...interface{}) {
	lg.info("", args)
}

func (lg *Logger) warn(format string, args []interface{}) {
	if lg.level > Lwarn {
		return
	}
	lg.output("[WARN]", format, args)
}

// Warnf writes the warning log, always adds a '\n' if no '\n' supplied by user
func (lg *Logger) Warnf(format string, args ...interface{}) {
	lg.warn(format, args)
}

// Warnln is like fmt.Println with loglevel warning
func (lg *Logger) Warnln(args ...interface{}) {
	lg.warn("", args)
}

func (lg *Logger) error(format string, args []interface{}) {
	if lg.level > Lerror {
		return
	}
	lg.output("[ERROR]", format, args)
}

// Errorf writes the error log, always adds a '\n' if no '\n' supplied by user
func (lg *Logger) Errorf(format string, args ...interface{}) {
	lg.error(format, args)
}

// Errorln is like fmt.Println with loglevel error
func (lg *Logger) Errorln(args ...interface{}) {
	lg.error("", args)
}

func (lg *Logger) fatal(format string, args []interface{}) {
	lg.output("[FATAL]", format, args)
}

// Fatalf writes the log entry followed by a panic, always adds a '\n' if no '\n' supplied by user
func (lg *Logger) Fatalf(format string, args ...interface{}) {
	lg.fatal(format, args)
	panic(fmt.Sprintf(format, args...))
}

// Fatalln is like fmt.Println with loglevel fatal followed by a panic
func (lg *Logger) Fatalln(args ...interface{}) {
	lg.fatal("", args)
	panic(fmt.Sprintln(args...))
}
